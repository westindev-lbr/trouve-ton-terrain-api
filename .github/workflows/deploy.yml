name: API Deploy

on:
  workflow_run:
    workflows: [ "API CI" ]
    types: [ completed ]
    branches: [ develop, master ]

permissions: 
  contents: read
  actions: read

concurrency:
  group: api-deploy-${{ github.event.workflow_run.head_branch }}
  cancel-in-progress: false

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    # On détermine l'environnement cible à partir de la branche
    outputs:
      target_env: ${{ steps.pick_env.outputs.target_env }}

    steps:
      - name: pick env from branch
        id: pick_env
        run: |
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          if [ "$BRANCH" = "develop" ]; then
            echo "target_env=dev" >> $GITHUB_OUTPUT
          elif [ "$BRANCH" = "master" ]; then
            echo "target_env=prod" >> $GITHUB_OUTPUT
          else
            echo "Unsupported branch: $BRANCH"; exit 1
          fi

  deploy_to_target:
    needs: deploy
    runs-on: ubuntu-latest
    environment: ${{ needs.deploy.outputs.target_env }}

    steps:
      - name: download artifact from CI run
        uses: actions/download-artifact@v4
        with:
          # Télécharge l'artefact du workflow_run déclencheur
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
          name: api_artifact
          path: .

      - name: prepare SSH
        run: |
          cat > /tmp/id_ci <<'EOF'
          ${{ secrets.SSH_KEY_VPS }}
          EOF
          chmod 600 /tmp/id_ci
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          ssh-keyscan -H "${{ secrets.SERVER_IP }}" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: probe ssh
        run: |
          ssh -i /tmp/id_ci -o IdentitiesOnly=yes -o BatchMode=yes ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} true

      - name: deploy (atomic release + PM2 reload)
        env:
          SERVER_IP:    ${{ secrets.SERVER_IP }}
          SERVER_USER:  ${{ secrets.SERVER_USER }}
          REMOTE_BASE:  ${{ vars.REMOTE_BASE }}
          APP_DIR:      ${{ vars.APP_DIR }}
          NODE_ENV:     ${{ vars.NODE_ENV }}
          PM2_CWD:      ${{ vars.PM2_CWD }}
        run: |
          set -e
          RELEASES_DIR="$REMOTE_BASE/$APP_DIR/releases"
          CURRENT_LINK="$REMOTE_BASE/$APP_DIR/current"
          TS="$(date +%Y%m%d%H%M%S)"
          TARGET_DIR="$RELEASES_DIR/$TS"

          ssh -i /tmp/id_ci -o IdentitiesOnly=yes $SERVER_USER@$SERVER_IP "mkdir -p $TARGET_DIR $RELEASES_DIR && mkdir -p $(dirname $CURRENT_LINK)"
          scp -i /tmp/id_ci -o IdentitiesOnly=yes api_artifact.tgz $SERVER_USER@$SERVER_IP:$TARGET_DIR/

          ssh -i /tmp/id_ci -o IdentitiesOnly=yes $SERVER_USER@$SERVER_IP "
            set -e
            cd $TARGET_DIR
            tar -xzf api_artifact.tgz && rm -f api_artifact.tgz
            npm ci --omit=dev
            ln -sfn '$TARGET_DIR' '$CURRENT_LINK'

            # Choix de l'env selon la branche
            if [ "${{ needs.deploy.outputs.target_env }}" = "dev" ]; then
              PM2_ENV="development"
            else
              PM2_ENV="production"
            fi

            # === PM2 depuis le symlink ===
            export PM2_CWD='$CURRENT_LINK'
            cd \"\$PM2_CWD\"

            # Reset + start pour éviter les chemins figés 
            pm2 delete trouve-ton-terrain-api || true
            pm2 start ecosystem.config.js --env \"\$PM2_ENV\"
            pm2 save
          "